# Подготовка к пониманию структур
## Что нам нужно знать для этого 
* Указатели
* Массивы
* Функции
* Структуры

# Что такое указатель ?
Указатель - это переменная, которая хранит адрес
<br>
Зачем нужны указатели ?
* Без указателей невозможно работать с массивами.
* Без указателей невозможно работать с динамической памятью.

Тут просто можно сделать вывод. Без указателей у нас всего 1MB памяти, а с указателями память бесконечна.
# Что такое массив ?
Массив - это последовательность однотипных данных
## Зачем нужен массив ? 
Массив нужен для удобного хранения больших данных
<br>
### Что в массиве по Complexity ?
* Доступ к элементу по индексу - O(1)
```c++
int arr[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
cout << arr << endl; // адрес первого элемента
cout << arr[9] << endl; // 10
cout << *(arr + 9) << endl; // 10
```
* Расширение массива на один элемент - O(n) n - это длина массива
```c++
int arr[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int arr2[11]{};
for (int i = 0; i < 10; i++) {
    arr2[i] = arr[i];
}
arr2[10] = 11;
```
* Поиск элемента в массиве - O(n) n - это длина массива
```c++
int arr[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int x = 5;
for (int i = 0; i < 10; i++) {
    if (arr[i] == x) {
        cout << "Element found" << endl;
        break;
    }
}
```
* Типы массивов по памяти:
* * Статический массив
* * Динамический массив

```c++
int arr[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // статический массив
int *arr2 = new int[10]; // динамический массив
```
arr - хранится в стэке
<br>
arr2 - хранится в стэке, а сам массив в куче

* Типы массива по размеру:
* * Одномерный массив
* * Многомерный массив
* * Зубчатый массив

```c++
// Одномерный массив
int arr[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
// Многомерный массив - это иллюзия, на самом деле это одномерный массив
int arr2[3][3] {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; 
// Зубчатый массив
int **arr3 = new int*[3] {
    new int[3] {1, 2, 3},
    new int[2] {4, 5},
    new int[4] {7, 8, 9, 10}
};
```

# Что такое функция ?
Функция - это вызываемая часть кода
<br>
### Зачем нужны функции ?
* Для удобства
* Для повторного использования кода
* Для уменьшения количества кода
* Для улучшения читаемости кода

### Что такое перегрузка функций ?
<br>
Перегрузка функций - это создание функций с одинаковым именем, но разными параметрами
<br>
*По каким параметрам бывает перегрузка функций ?*
* По типу возвращаемого значения
* По количеству параметров
* По типу параметров

<br>
Что такое шаблонная функция ?
<br>

### Шаблонная функция - это функция, которая может принимать любой тип данных

```c++
template <typename T>
T sum(T a, T b) {
    return a + b;
}
```
<br>

### Зачем нужны шаблонные функции ?
<br>
Шаблонные функции нужны для предотвращения ненужной перегрузки функций
<br>

### Что такое параметр по умолчанию ?
<br>
Параметр по умолчанию - это параметр, который имеет значение по умолчанию
<br>

* Зачем нужны параметры по умолчанию ?
* * Параметры по умолчанию нужны для предотвращения ненужной перегрузки функций
* * Правило для параметров по умолчанию
<br>
Параметры по умолчанию должны быть справа

```c++

void foo(int a, int b =0) {
    if (b == 0)
        cout << a << endl;
    else
        cout << a << ' ' << b << endl;
}
```

# Что такое структура ?
Структура - это пользовательский тип данных(user defined data type)

***Запомните раз и навсегда. Структура это всего лишь новый тип данных***

```c++
struct Point {
    int x;
    int y;
};

int a;
Point p;

```
P.S. В пайтоне мы писали 

```python
name = "Elvin"
print(name.upper()) # Тут можете расценивать name как объект структуры String
```


### Задача: Нужно создать 10 квадратов, у которых есть свой размер и позиция X, Y

```c++


struct Position {
    int x;
    int y;
};

struct Square {
    Position pos;
    int size;
};

struct Circle {
    Position pos;
    int radius;
};

struct GeometryClass {
    Square createSquare(Position pos,  int size) {
        Square s;
        s.pos = pos;
        s.size = size;
        return s;
    }
    
    Circle createCircle(Position pos, int radius) {
        Circle c;
        c.pos = pos;
        c.radius = radius;
        return c;
    }
}


