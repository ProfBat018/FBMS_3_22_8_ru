# SOLID

## Single Responsibility Principle
## Open Closed Principle
## Liskov Substitution Principle
## Interface Segregation Principle
## Dependency Inversion Principle

1. SRP - говорит о том, что каждая сущность должна отвечать
за одно действие. 
2. OCP - говорит о том, что сущность должна быть открыта для расширения, 
но закрыта для модификаций.
3. LSP - говорит о том, что поведение сущности в дочерних классах не должно
противоречить поведению родительского класса.
4. ISP - говорит о том, что сущность не должна зависеть от методов, которые
она не использует.
5. DIP - говорит о том, что сущность не должна зависеть от конкретных
реализаций, а от абстракций.

[Еще одна хорошая статья](https://habr.com/ru/articles/561216/)


## Single Responsibility Principle
Принцип единственной ответственности гласит, что каждый класс должен решать
одну задачу. Класс должен быть простым и иметь только одну причину для изменений.

## Open Closed Principle
Принцип открытости/закрытости гласит, что программные сущности должны быть
открыты для расширения, но закрыты для модификации.

## Liskov Substitution Principle
Принцип подстановки Барбары Лисков гласит, что объекты в программе должны
быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения
программы.

## Interface Segregation Principle
Принцип разделения интерфейса гласит, что клиенты не должны зависеть от методов,
которые они не используют. К примеру, если у нас есть интерфейс с 10 методами,
а в классе, который его реализует, используется только 3 метода, то нужно
разделить этот интерфейс на 2 интерфейса, чтобы класс реализовывал только
те методы, которые ему нужны. Это относится ко всем классам. 

## Dependency Inversion Principle
Принцип инверсии зависимостей гласит, что высокоуровневые модули не должны
зависеть от низкоуровневых модулей. Оба типа модулей должны зависеть от
абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть
от абстракций.

Давайте начнес с того, что инверсия - В данном случае несет немного другой
смысл.

Предположим, что у нас есть класс `User` и класс `UserRepository`. Класс
`UserRepository` зависит от класса `User`, так как в нем есть методы, которые
принимают в качестве аргумента объект класса `User`. Таким образом, класс
`UserRepository` зависит от класса `User`. Но если мы захотим изменить
класс `User`, то нам придется изменить класс `UserRepository`.

Чтобы решить эту проблему, мы можем создать интерфейс `UserInterface`, который
будет содержать все методы класса `User`. Таким образом, класс `UserRepository`
будет зависеть от интерфейса `UserInterface`, а не от класса `User`. Если мы
захотим изменить класс `User`, то нам не придется изменять класс `UserRepository`,
так как он зависит от интерфейса `UserInterface`, а не от класса `User`.





