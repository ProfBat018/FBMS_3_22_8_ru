# Тема урока: Garbage Collection

В .NET есть механизм, который автоматически удаляет объекты, которые больше не используются. Этот механизм называется сборщиком мусора (Garbage Collector).

### Как работает память ? 
Перед тем, как говорить про `GC`, 
нужно понимать как работает память в .NET.

В .NET есть 2 типа памяти:
- **Managed heap** - управляемая память
- **Unmanaged heap** - неуправляемая память

Конечно же не забываем про `Stack`.
В C# стэк весит в зависимости от архитектуры процессора,
в 32 битной архитектуре он весит 1 Мб, в 64 битной - 4 Мб.

Это, не тот stack, как в С++. Есть два типа данных: 
1. Value type
2. Reference type

**Value type** - это типы данных, которые хранятся в стэке.
**Reference type** - это типы данных, которые хранятся в куче.

Но учтите что все переменные хранятся в стэке, и 
если ваша переменная является ссылочным типом, то в стэке хранится ссылка на объект в куче.

Стэк по сути обычный, как в С++. 
Единственное отличие, 
что он выделяется не на этапе первой компиляции(из c# в IL),
а на этапе компилляции IL в машинный код.

### Как работает куча ?

Вот тут уже очень интересно. 😈😈😈

Есть два типа кучи:
1. **Managed heap** - управляемая куча
2. **Unmanaged heap** - неуправляемая куча

В управляемой куче хранятся объекты, которые создаются во время выполнения программы.

В неуправляемой куче хранятся объекты, которые создаются во время выполнения программы, но не управляются сборщиком мусора.
К таким объектам относятся например: `FileStream`, `SqlConnection` и т.д.
То есть они попадают в неуправляемую кучу, потому что они используют неуправляемые ресурсы(потоки).
Когда вы вызываете `Dispose` или `Close` у таких объектов, то они освобождают неуправляемые ресурсы, но не освобождают память в куче.
После этого уже они попадают под управление сборщика мусора.

Чтобы попасть в очередь на удаление, надо сперва разобраться с поколениями.

## Поколения
1. SOH - Small Object Heap
2. LOH - Large Object Heap
3. POH - Pinned Object Heap

### SOH - Small Object Heap

В SOH хранятся объекты размером до 85 Кб.(условно)
Когда вы создаете объект только, то он попадает в SOH.

Сам SOH делится на 3 поколения:
1. 2 поколение -  любой новый объект попадает в 2 поколение (если он помещается в SOH)
2. 1 поколение - объекты, которые выжили одну сборку мусора
3. 0 поколение - объекты, которые выжили две сборки мусора

Мало кто знает, но есть несколько фрагментов SOH:
1. SOH 1. Он состоит из 3 частей
2. Ephemeral segment - сюда попадают объекты, которые выжили одну сборку мусора
2. SOH 2. Он состоит из 3 частей

### LOH - Large Object Heap

В LOH хранятся объекты размером больше 85 Кб.(условно)

Сюда попадают объекты, которые не помещаются в SOH или выижили 3 сборки мусора и стали больше.

Чтобы элемент сразу попал в LOH, нужно указать атрибут `[<MethodImpl(MethodImplOptions.AggressiveInlining)]` перед методом.
Вряд ли вам придется работать с LOH. Это вообще никому не нужно. 

Чтобы по умолчанию объект попал в LOH, ему нужно пройти все этапы в SOH.

#### Есть лайфхак, который поможет вам понять как работает память.
1. Объем данных
2. Частота использования


Если объект весит мало и часто используется, то он попадает в SOH 2 поколение.

Если объект весит мало и редко используется, то он попадает в SOH 2 поколение, 
при следующей сборке мусора он попадает(скорее всего) в SOH 1 поколение.

Если объект весит много и часто используется, то он попадает в SOH 2 поколение 
и тут уже учитыается то, насколько часто он используется и увеличивается в объеме






