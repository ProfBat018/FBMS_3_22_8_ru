# Синхронизация потоков 


### I/O и CPU bound операции 


#### I/O
Если ваш поток выполняет какой-то

`Console.WriteLine();` который в свою очередь
выполняется долго или вызывает внутри себя 
какие-то функции, или вы делаете запрос на 
ввод данных с клавиатуры, то это называется
I/O bound операция.

`Bound` - переводится как "ограничение",
то есть ваш поток в котором выолнялось данная 
операция будет ждать пока вы сделаете ввод или
ваш вывод данных осуществится. 

#### CPU 

`CPU bound` - это операции которые выполняются долго 
уже на уровне процессора, например вы вполняете сложные 
математические операции, или вы делаете какие-то
запросы к базе данных, которые занимают много времени.

## Методы синхронизации потоков

Есть ряд инструментов для синхронизации потоков,
среди которых есть как специальные классы, так и
просто ключевые слова. Вы должны понимать в чем 
их разница и когда их использовать.

1. `lock`
2. `Mutex`
3. `Semaphore`
4. `SemaphoreSlim`

Пока что мы будем изучать эти методы и потом 
перейдем к другим методам синхронизации потоков, как 
например `AutoResetEvent` и `ManualResetEvent`.

## lock
Он на самом деле является синтактическим сахаром для
класса `Monitor`. Если мы зайдем в `IL` код, то увидим 
блок try-finally, в котором вызывается метод `Monitor.Enter`
и в блоке `finally` вызывается метод `Monitor.Exit`. 

`lock` не самый лучший способ синхронизации потоков,
так как он не позволяет управлять таймаутами, и он не
позволяет управлять количеством потоков, которые могут
войти в критическую секцию(код, который находится внутри)

Он может передать управление другому потоку, который
будет ждать пока текущий поток завершит свою работу.


## Mutex 

`Mutex` - это более гибкий инструмент для синхронизации



